============================================================================
            Everything You Always Wanted To Know About GAMEBOY *
==============================================================================

                        * but were afraid to ask


                           Pan Document Updated

                      Last update 25-Sept-97 by kOOPa

 Forward: The following was typed up for informational purposes regarding
          the inner workings on the hand-held game machine known as
          GameBoy, manufactured and designed by Nintendo Co., LTD.
          This info is presented to inform a user on how their Game Boy
          works and what makes it "tick". GameBoy is copyrighted by
          Nintendo Co., LTD. Any reference to copyrighted material is
          not presented for monetary gain, but for educational purposes
          and higher learning.


Game Boy Specs
--------------

 CPU: 8-bit (Similiar to the Z80 processor.)
 Main RAM: 8K Byte
 Video RAM: 8K Byte
 Screen Size 2.6"
 Resolution: 160x144
 Max # of sprites: 40
 Max # sprites/line: 10
 Max sprite size: 8x16
 Min sprite size: 8x8
 Clock Speed: 4.194304 MHz
 Sound: 4 channels with stereo sound
 Power: DC6V 0.7W


Processor
---------

 The GameBoy uses a computer chip similiar to an Intel 8080.
 It contains all of the instructions of an 8080 except there
 are no exchange instructions. In many ways the processor is
 more similiar to the Zilog Z80 processor. Compared to the
 Z80, some instructions have been added and some have been
 taken away.

 The following are new instructions:

  LDI (HL),#$xx
  LDD (HL),#$xx
  SWAP A through L
  LD A,($FFxx)

 The following instructions have been removed:

  Any command that uses the IX or IY registers.
  All input or output instructions.
  All exchange instructions.
  All 'jp' or 'call' instructions based on M or P flags.

 The following instructions have changed:

  'ld a,[x]' and 'ld [x],a' have different opcodes.
  'reti' has a different opcode.


General Memory Map*                  Hardware Write Registers
------------------                   ------------------------

  Interrupt Enable Register
 --------------------------- FFFF
  Internal RAM
 --------------------------- FF80
  Empty but unusable for I/O
 --------------------------- FF4C
  I/O ports
 --------------------------- FF00
  Empty but unusable for I/O
 --------------------------- FEA0
  Sprite Attrib Table (OAM)
 --------------------------- FE00
  Echo of 8kB Internal RAM
 --------------------------- E000
  8kB Internal RAM
 --------------------------- C000       -------------------------
  8kB switchable RAM bank              /      MBC1 ROM/RAM Select
 --------------------------- A000     /  ------------------------
  8kB Video RAM                      /  /     RAM Bank Select
 --------------------------- 8000 --/  /  -----------------------
  16kB switchable ROM bank   6000 ----/  /    ROM Bank Select
 --------------------------- 4000 ------/  ----------------------
  16kB ROM bank #0           2000 --------/   RAM Bank enable
 --------------------------- 0000 -------------------------------

 * NOTE: b = bit, B = byte


Echo of 8kB Internal RAM
------------------------

 The addresses E000-FE00 appear to access the internal RAM
the same as C000-DE00. (i.e. If you write a byte to address
E000 it will appear at C000 and E000. Similarly, writing a
byte to C000 will appear at C000 and E000.)


User I/O
--------

 There are no empty spaces in the memory map for
implementing input ports except the switchable RAM bank
area (not an option on the Super Smart Card since it's
RAM bank is always enabled).

 An output only port may be implemented anywhere between
A000-FDFF. If implemented in a RAM area care should be
taken to use an area of RAM not used for anything else.
(FE00 and above can't be used because the CPU doesn't
generate an external /WR for these locations.)

 If you have a cart with an MBC1, a ROM 4Mbit or smaller,
and a RAM 8Kbyte or smaller (or no RAM) then you can use
pins 6 & 7 of the MBC1 for 2 digital output pins for
whatever purpose you wish. To use them you must first
put the MBC1 into 4MbitROM/32KbyteRAM mode by writing
01 to 6000. The two least significant bits you write
to 4000 will then be output to these pins.


Cart Memory Info
----------------

0040       Vertical Blank Interrupt Start Address

0048       LCDC Status Interrupt Start Address

0050       Timer Overflow Interrupt Start Address

0058       Serial Transfer Completion Interrupt Start Address

0060       High-to-Low of P10-P13 Interrupt Start Address

An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

0100-0103  This is the begin code execution point in a
           cart. Usually there is a NOP and a JP
           instruction here but not always.

0104-0133  Scrolling Nintendo graphic:
           CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
           00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
           BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E
           ( PROGRAM WON'T RUN IF CHANGED!!!)

0134-0143  Title of the game in UPPER CASE ASCII. If it
           is less than 16 characters then the remaining
           bytes are filled with 00's.

0144       Ascii hex digit, high nibble of licensee code.
0145       Ascii hex digit, low nibble of licensee code.

           Note: 0144-0145 are zero for non-super gameboy games.

0146       SGB features (00 = GameBoy, 03 = Super GameBoy functions)


0147       Cartridge type:
           0 - ROM ONLY               5 - ROM+MBC2
           1 - ROM+MBC1               6 - ROM+MBC2+BATTERY
           2 - ROM+MBC1+RAM           8 - ROM+RAM
           3 - ROM+MBC1+RAM+BATTERY   9 - ROM+RAM+BATTERY
                                     FF - ROM+HuC1+RAM+BATTERY

0148       ROM size:
            0 - 256Kbit =  32KByte =   2 banks
            1 - 512Kbit =  64KByte =   4 banks
            2 -   1Mbit = 128KByte =   8 banks
            3 -   2Mbit = 256KByte =  16 banks
            4 -   4Mbit = 512KByte =  32 banks
            5 -   8Mbit =   1MByte =  64 banks
            6 -  16Mbit =   2MByte = 128 banks
           52 -   9Mbit = 1.1MByte =  72 banks
           53 -  10Mbit = 1.2MByte =  80 banks
           54 -  12Mbit = 1.5MByte =  96 banks

0149       RAM size:
           0 - None
           1 -  16kBit =  2kB = 1 bank
           2 -  64kBit =  8kB = 1 bank
           3 - 256kBit = 32kB = 4 banks

014A       Destination code:
           0 - Japanese
           1 - Non-Japanese

014B       Licensee code:
           33 - Super GameBoy game.
                Check 0144/0145 for Licensee code.
           79 - Accolade
           A4 - Konami

014C       Mask ROM Version number

014D       Complement check
           (PROGRAM WON'T RUN IF NOT CORRECT!!!)

014E-014F  Checksum (higher byte first) produced by
           adding all bytes of a cartridge except for two
           checksum bytes and taking two lower bytes of
           the result. (GameBoy ignores this value.)


Cartridge Types
---------------

The following define the byte at cart location 0147:

 ROM ONLY
  This is a 32kB (256kb) ROM and occupies 0000-7FFF.

 MBC1 (Memory Bank Controller 1)
   MBC1 has two different maximum memory modes:
  16Mbit ROM/8KByte RAM  or  4Mbit ROM/32KByte RAM.

   The MBC1 defaults to 16Mbit ROM/8KByte RAM mode
  on power up. Writing a value (XXXXXXXS - X = Don't
  care, S = Memory model select) into 6000-7FFF area
  will select the memory model to use. S = 0 selects
  16/8 mode. S = 1 selects 4/32 mode.

   Writing a value (XXXBBBBB - X = Don't cares, B =
  bank select bits) into 2000-3FFF area will select an
  appropriate ROM bank at 4000-7FFF. Values of 0 and 1
  do the same thing and point to ROM bank 1. Rom bank 0
  is not accessible from 4000-7FFF and can only be read
  from 0000-3FFF.

  If memory model is set to 4/32:
    Writing a value (XXXXXXBB - X = Don't care, B =
   bank select bits) into 4000-5FFF area will select an
   appropriate RAM bank at A000-C000. Before you can
   read or write to a RAM bank you have to enable it by
   writing a XXXX1010 into 0000-1FFF area*. To disable
   RAM bank operations write any value but XXXX1010
   into 0000-1FFF area. Disabling a RAM bank probably
   protects that bank from false writes during power
   down of the GameBoy. (NOTE: Nintendo suggests values
   0A to enable and 00 to disable RAM bank!!)

  If memory model is set to 16/8 mode:
    Writing a value (XXXXXXBB - X = Don't care, B =
   bank select bits) into 4000-5FFF area will set the
   two most significant ROM address lines.

  * NOTE: The Super Smart Card doesn't require this
   operation because it's RAM bank is ALWAYS enabled.
   Include this operation anyway to allow your code
   to work with both.

 MBC2 (Memory Bank Controller 2):
   This memory controller works much like the MBC1
  controller with the following exceptions:

   MBC2 will work with ROM sizes up to 2Mbit.

   Writing a value (XXXXBBBB - X = Don't cares, B =
  bank select bits) into 2000-3FFF area will select an
  appropriate ROM bank at 4000-7FFF.

   RAM switching is not provided. Unlike the MBC1 which
  uses external RAM, MBC2 has 512 x 4 bits of RAM which
  is in the controller itself. It still requires an
  external battery to save data during power-off though.

   The least significant bit of the upper address byte
  must be zero to enable/disable cart RAM. For example
  the following addresses can be used to enable/disable
  cart RAM:
  0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
  The suggested address range to use for MBC2 ram
  enable/disable is 0000-00FF.

   The least significant bit of the upper address byte
  must be one to select a ROM bank. For example the
  following addresses can be used to select a ROM bank:
  2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
  The suggested address range to use for MBC2 rom
  bank selection is 2100-21FF.


Power Up Sequence
-----------------

  When the GameBoy is powered up, a 256 byte program
 starting at memory location 0 is executed. This program
 is located in a ROM inside the GameBoy. The first thing
 the program does is read the cartridge locations from
 $104 to $133 and place this graphic of a Nintendo logo
 on the screen at the top. This image is then scrolled
 until it is in the middle of the screen. Two musical
 notes are then played on the internal speaker. Again,
 the cartridge locations $104 to $133 are read but this
 time they are compared with a table in the internal rom.
 If any byte fails to compare, then the GameBoy stops
 comparing bytes and simply halts all operations. If all
 locations compare the same, then the GameBoy starts
 adding all of the bytes in the cartridge from $134 to
 $14d. A value of 25 decimal is added to this total. If
 the least significant byte of the result is a not a
 zero, then the GameBoy will stop doing anything. If it
 is a zero, then the internal ROM is disabled and
 cartridge program execution begins at location $100
 with AF=$01B0, BC=$0013, DE=$00D8, HL=$014D and
 Stack Pointer=$FFFE.


Low-Power Mode
--------------

  It is recommended that the HALT instruction be used
 whenever possible to reduce power consumption & extend
 the life of the batteries. This command stops the
 system clock reducing the power consumption of both
 the CPU and ROM.
  The CPU will remain suspended until an interrupt
 occurs at which point the interrupt is serviced and
 then the instruction immediately following the HALT
 is executed.


Video
-----

  The main GameBoy screen buffer (aka background) consists
 of 256x256 pixels or 32x32 tiles (8x8 pixels each). Only
 160x144 pixels can be displayed on the screen. Registers
 SCROLLX and SCROLLY hold the coordinates of background to
 be displayed in the left upper corner of the screen.
 Background wraps around the screen (i.e. when part of it
 goes off the screen, it appears on the opposite side.)

  An area of VRAM known as Background Tile Map contains
 the numbers of tiles to be displayed. It is organized as
 32 rows of 32 bytes each. Each byte contains a number of
 a tile to be displayed. Tile patterns are taken from the
 Tile Data Table located either at 8000-8FFF or
 8800-97FF. In the first case, patterns are numbered with
 unsigned numbers from 0 to 255 (i.e. pattern #0 lies at
 address 8000). In the second case, patterns have signed
 numbers from -128 to 127 (i.e. pattern #0 lies at address
 9000). The Tile Data Table address for the background
 can be selected via LCDC register.

  Besides background, there is also a "window" overlaying
 the background. The window is not scrollable i.e. it is
 always displayed starting from its left upper corner. The
 location of a window on the screen can be adjusted via
 WNDPOSX and WNDPOSY registers. Screen coordinates of the
 top left corner of a window are WNDPOSX-7,WNDPOSY. The
 tile numbers for the window are stored in the Tile Data
 Table. Both the Background and the window share the same
 Tile Data Table.

  Both background and window can be disabled or enabled
 separately via bits in the LCDCONT register.

  The tile images are stored in the Tile Pattern Tables.
 Each 8x8 image occupies 16 bytes, where each 2 bytes
 represent a line:

  Tile:                                     Image:

  .33333..                     .33333.. -> 01111100 -> 7Ch
  22...22.                                 01111100 -> 7Ch
  11...11.                     22...22. -> 00000000 -> 00h
  2222222. <-- digits                      11000110 -> C6h
  33...33.     represent       11...11. -> 11000110 -> C6h
  22...22.     color                       00000000 -> 00h
  11...11.     numbers         2222222. -> 00000000 -> 00h
  ........                                 11111110 -> FEh
                               33...33. -> 11000110 -> C6h
                                           11000110 -> C6h
                               22...22. -> 00000000 -> 00h
                                           11000110 -> C6h
                               11...11. -> 11000110 -> C6h
                                           00000000 -> 00h
                               ........ -> 00000000 -> 00h
                                           00000000 -> 00h

  As it was said before, there are two Tile Pattern Tables
 at 8000-8FFF and at 8800-97FF. The first one can be used
 for sprites and the background. Its tiles are numbered
 from 0 to 255. The second table can be used for the
 background and the window display and its tiles are
 numbered from -128 to 127.


Sprites
------

  GameBoy video controller can display up to 40 sprites
 either in 8x8 or in 8x16 pixels. Because of a limitation
 of hardware, only ten sprites can be displayed per scan
 line. Sprite patterns have the same format as tiles, but
 they are taken from the Sprite Pattern Table located at
 8000-8FFF and therefore have unsigned numbers. Sprite
 attributes reside in the Sprite Attribute Table (aka OAM)
 at FE00-FE9F. OAM is divided into 40 4-byte blocks each
 of which corresponds to a sprite.

  When sprites with different x coordinate values overlap,
 the one with the smaller x coordinate (closer to the left)
 will have priority and appear above any others.

  When sprites with the same x coordinate values overlap,
 they have priority according to table ordering. (i.e.
 FE00 - highest, FE04 - next highest, etc.)

 Blocks have the following
 format:

  Byte0  Y position on the screen
  Byte1  X position on the screen
  Byte2  Pattern number 0-255 [notice that unlike tile
         numbers, sprite pattern numbers are unsigned]
  Byte3  Flags:

         Bit7  Priority
               If this bit is set to 0, sprite is displayed
               on top of background & window. If this bit
               is set to 1, then sprite will be hidden behind
               colors 1, 2, and 3 of the background & window.
               (Sprite only prevails over color 0 of BG & win.)
         Bit6  Y flip
               Sprite pattern is flipped vertically if
               this bit is set to 1.
         Bit5  X flip
               Sprite pattern is flipped horizontally if
               this bit is set to 1.
         Bit4  Palette number
               Sprite colors are taken from OBJ1PAL if
               this bit is set to 1 and from OBJ0PAL
               otherwise.


Sprite RAM Bug
--------------

  There is a flaw in the GameBoy hardware that causes
 trash to be written to OAM-RAM if the following commands
 are used while their 16-bit content is in the range
 of $FE00 to $FE9F:

  inc xx     (xx = bc,de, or hl)
  dec xx

  ldi a,(hl)
  ldd a,(hl)

  ldi (hl),a
  ldd (hl),a


Sound
-----

  There are two sound channels connected to the output
 terminals SO1 and SO2. There is also a input terminal Vin
 connected to the cartridge. It can be routed to either of
 both output terminals. GameBoy circuitry allows producing
 sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions
   Quadrangular wave patterns with envelope functions
   Voluntary wave pattern
   White noise

  These four sounds can be controlled independantly and
 then mixed separately for each of the output terminals.


Timer
-----

  Sometimes it's useful to have a timer that interrupts at
 regular intervals for routines that require periodic or
 percise updates. The timer in the GameBoy has a selectable
 frequency of 4096, 16384, 65536, or 262144 Hertz. This
 frequency increments the Timer Counter (TIMA). When it
 overflows, it generates an interrupt. It is then loaded
 with the contents of Timer Modulo (TMA). The following
 are examples:

 ;This interval timer interrupts 4096 times per second

     ld  a,$ff
     ldh (6),a     ;Set TMA to divide clock by 1
     ld  a,4
     ldh (7),a     ;Set clock to 4096 Hertz

 ;This interval timer interrupts 65536 times per second

     ld  a,256-4
     ldh (6),a     ;Set TMA to divide clock by 4
     ld  a,5
     ldh (7),a     ;Set clock to 262144 Hertz


Serial I/O
----------

  The serial I/O port on the Gameboy is a very simple setup
 and is crude compared to standard RS-232 (IBM-PC) or RS-485
 (Macintosh) serial ports. There are no start or stop bits
 so the programmer must be more creative when using this port.

  During a transfer, a byte is shifted in at the same time
 that a byte is shifted out. The rate of the shift is deter-
 mined by whether the clock source is internal or external.
 If internal, the bits are shifted out at a rate of 8192Hz
 (122 microseconds) per bit. The most significant bit is
 shifted in and out first.

  When the internal clock is selected, it drives the clock
 pin on the game link port and it stays high when not used.
 During a transfer it will go low eight times to clock
 in/out each bit.

  A programmer initates a serial transfer by setting bit 7 of
 $FF02. An interrupt will then occur eight bit clocks later
 if the serial interrupt is enabled.
  If internal clock is selected and serial interrupt is
 enabled, this interrupt occurs 122*8 microseconds later.
  If external clock is selected and serial interrupt is
 enabled, an interrupt will occur eight bit clocks later.

  Initiating a serial transfer with external clock will
 wait forever if no external clock is present. This allows
 a certain amount of synchronization with each serial port.

  The state of the last bit shifted out determines the
 state of the output line until another transfer takes
 place.

  If a serial transfer with internal clock is performed
 and no external GameBoy is present, all ones will be
 shifted in on the receive byte.

  The following code causes $75 to be shifted out the
 serial port and a byte to be shifted into $FF01:

    ld   a,$75
    ld  ($ff01),a
    ld   a,$81
    ld  ($ff02),a


Interrupt Procedure
-------------------

  The IME (interrupt master enable) flag is reset by DI and
 prohibits all interrupts. It is set by EI and acknowledges
 the interrupt setting by the IE register.

 1. When an interrupt is generated, the IF flag will be set.
 2. If the IME flag is set & the corresponding IE flag is
    set, the following 3 steps are performed.
 3. Reset the IME flag and prevent all interrupts.
 4. The PC (program counter) is pushed onto the stack.
 5. Jump to the starting address of the interrupt.

  Resetting of the IF register, which was the cause of the
 interrupt, is done by hardware.

  During the interrupt, pushing of registers to be used
 should be performed by the interrupt routine.

  Once the interrupt service is in progress, all the
 interrupts will be prohibited. However, if the IME flag
 and the IE flag are controlled, a number of interrupt
 services can be made possible by nesting.

  Return from an interrupt routine can be performed be
 either RETI or RET instruction.

  The RETI instruction restores the IME state before an
 interrupt. Any DI or EI done before the RETI is cancelled.

  If a RET is used as the final instruction in an interrupt
 routine, interrupts will remain disabled unless a EI was
 used in the interrupt routine.

  The interrupt will be acknowledged during opcode fetch
 period of each instruction.


I/O Registers
-------------

FF00
   Name     - P1
   Contents - Register for reading joy pad info
              and determining system type.    (R/W)

           Bit 7 - Not used
           Bit 6 - Not used
           Bit 5 - P15 out port
           Bit 4 - P14 out port
           Bit 3 - P13 in port
           Bit 2 - P12 in port
           Bit 1 - P11 in port
           Bit 0 - P10 in port

        To determine what type of GameBoy this is write an 03
        to this register then read it back. An Fx indicates
        GameBoy or GameBoy Pocket, 3x indicates Super GameBoy.
        (The 'x' indicates a don't care value.)

         This is the matrix layout for register $FF00:


                 P14        P15
                  |          |
        P10-------O-Right----O-A
                  |          |
        P11-------O-Left-----O-B
                  |          |
        P12-------O-Up-------O-Select
                  |          |
        P13-------O-Down-----O-Start
                  |          |


        This is the logic in reading joy pad data:

          Turn on P15 (bit 5) in $ff00
          Wait a few clock cycles
          read $ff00 into A
          invert A   - same as EOR #$FF - just reverse all
                       bits apparently the joy pad info
                       returned is like the C64 info.
                       0 means on, 1 means off. But logic
                       tells us that it should be the
                       other way around. So to make it
                       less confusing we just flip the bits!

          AND A w/ #$0F - Get only the first four bits.
                          By turning on P15 we are trying
                          to read column P15 in the matrix
                          layout. It contains A,B,SEL,STRT

          SWAP A - #$3f becomes #$f3, it swaps hi<->lo nibbles

          store A in B for backup


          Turn on P14 (bit 4) in $ff00
          Wait a few more clock cycles
          read $ff00 into A
          invert A - just as above
          AND A with #$0F - get first 4 bits
                          - By turning on P14 we get the
                            data for column P14 in the
                            matrix layout. It contains
                            U,D,L,& R.

          OR A with B - put the two values together.

          turn on P14 and P15 in $ff00 to reset.

          The button values using the above method are such:
          $80 - Start             $8 - Down
          $40 - Select            $4 - Up
          $20 - B                 $2 - Left
          $10 - A                 $1 - Right

          Let's say we held down A, Start, and Up.
          The value returned in accumulator A would be $94

       Example:
          Game: Ms. Pacman
          Address: $3b1

        LD A,$20       <- bit 5 = $20
        LD ($FF00),A   <- turn on P15
        LD A,($FF00)
        LD A,($FF00)   <- wait a few cycles
        CPL            <- complement (invert) EOR #$ff
        AND $0F        <- get only first 4 bits
        SWAP A         <- swap it
        LD B,A         <- store A in B
        LD A,$10       <- bit 4 = $10
        LD ($FF00),A   <- turn on P14
        LD A,($FF00)
        LD A,($FF00)
        LD A,($FF00)
        LD A,($FF00)
        LD A,($FF00)
        LD A,($FF00)   <- Wait a few MORE cycles
        CPL            <- complement (invert)
        AND $0F        <- get first 4 bits
        OR B           <- put A and B together

        LD B,A         <- store A in D
        LD A,($FF8B)   <- read old joy data from ram
        XOR B          <- toggle w/current button bit
        AND B          <- get current button bit back
        LD ($FF8C),A   <- save in new Joydata storage
        LD A,B         <- put original value in A
        LD ($FF8B),A   <- store it as old joy data


        LD A,$30       <- turn on P14 and P15
        LD ($FF00),A   <- RESET Joypad?!
        RET            <- Return from Subroutine


FF01
   Name     - SB
   Contents - Serial transfer data (R/W)

              8 Bits of data to be read/written

FF02
   Name     - SC
   Contents - SIO control  (R/W)

              Bit 7 - Transfer start flag
                      0: Non transfer
                      1: Start transfer

              Bit 0 - Shift Clock
                      0: External Clock
                      1: Internal Clock (8192Hz)

FF04
   Name     - DIV
   Contents - Divider Register (R/W)

              This register is incremented 16384 times
              a second. Writing any value sets it to $00.
FF05
   Name     - TIMA
   Contents - Timer counter (R/W)

              The timer generates an interrupt when it overflows.

FF06
   Name     - TMA
   Contents - Timer Modulo (R/W)

              When the TIMA overflows, this data will be loaded.

FF07
   Name     - TAC
   Contents - Timer Control

              Bit 2 - Timer Stop
                      0: Stop Timer
                      1: Start Timer

              Bits 1+0 - Input Clock Select
                         00: 4.096 khz
                         01: 262.144 khz
                         10: 65.536 khz
                         11: 16.384 khz

FF0F
   Name     - IF
   Contents - Interrupt Flag (R/W)

              Bit 4: Transition from High to Low of Pin number P10-P13
              Bit 3: Serial I/O transfer end
              Bit 2: Timer Overflow
              Bit 1: LCDC (see STAT)
              Bit 0: V-Blank

   The priority and jump address for the above 5 interrupts are:

    Interrupt        Priority        Start Address

    V-Blank             1              $0040
    LCDC Status         2              $0048 - Modes 0, 01, 10
                                               LYC=LY coincide (selectable)
    Timer Overflow      3              $0050
    Serial Transfer     4              $0058 - when transfer is complete
    Hi-Lo Of P10-P13    5              $0060

    * When more than 1 interrupts occur at the same time
      only the interrupt with the highest priority can be
      acknowledged. When an interrupt is used a '0' should
      be stored in the IF register before the IE register
      is set.


FF10
   Name     - NR 10
   Contents - Sound Mode 1 register, Sweep register (R/W)

              Bit 6-4 - Sweep Time
              Bit 3   - Sweep Increase/Decrease
                         0: Addition    (frequency increases)
                         1: Subtraction (frequency decreases)
              Bit 2-0 - Number of sweep shift (n: 0-7)

              Sweep Time: 000: sweep off - no freq change
                          001: 7.8 ms  (1/128Hz)
                          010: 15.6 ms (2/128Hz)
                          011: 23.4 ms (3/128Hz)
                          100: 31.3 ms (4/128Hz)
                          101: 39.1 ms (5/128Hz)
                          110: 46.9 ms (6/128Hz)
                          111: 54.7 ms (7/128Hz)

              The change of frequency (NR13,NR14) at each shift
              is calculated by the following formula where
              X(0) is initial freq & X(t-1) is last freq:

               X(t) = X(t-1) +/- X(t-1)/2^n    

FF11
   Name     - NR 11
   Contents - Sound Mode 1 register, Sound length/Wave pattern duty (R/W)
              
              Only Bits 7-6 can be read.

              Bit 7-6 - Wave Pattern Duty
              Bit 5-0 - Sound length data (t1: 0-63)

              Wave Duty: 00: 12.5%
                         01: 25%
                         10: 50%
                         11: 75%

              Sound Length = (64-t1)*(1/256) seconds
FF12
   Name     - NR 12
   Contents - Sound Mode 1 register, Envelope (R/W)

              Bit 7-4 - Initial volume of envelope
              Bit 3 -   Envelope UP/DOWN
                         0: Attenuate
                         1: Amplify
              Bit 2-0 - Number of envelope sweep (n: 0-7)
                        (If zero, stop envelope operation.)

              Initial volume of envelope is from 0 to $F.
              Zero being no sound.

              Length of 1 step = n*(1/64) seconds


FF13
   Name     - NR 13
   Contents - Sound Mode 1 register, Frequency lo (W)

              Lower 8 bits of 11 bit frequency (x).
              Next 3 bit are in NR 14 ($FF14)

FF14
   Name     - NR 14
   Contents - Sound Mode 1 register, Frequency hi (R/W)

              Only Bit 6 can be read.

              Bit 7 - Initial (when set, sound restarts)
              Bit 6 - Counter/consecutive selection
              Bit 2-0 - Frequency's higher 3 bits (x)

              Frequency = 4194304/(32*(2048-x)) Hz
                        = 131072/(2048-x) Hz

FF16
   Name     - NR 21
   Contents - Sound Mode 2 register, Sound Length; Wave Pattern Duty (R/W)

              Only bits 7-6 can be read.

              Bit 7-6 - Wave pattern duty
              Bit 5-0 - Sound length data (t1: 0-63)

              Wave Duty: 00: 12.5%
                         01: 25%
                         10: 50%
                         11: 75%

              Sound Length = (64-t1)*(1/256) seconds

FF17
   Name     - NR 22
   Contents - Sound Mode 2 register, envelope (R/W)

              Bit 7-4 - Initial volume of envelope
              Bit 3 -   Envelope UP/DOWN
                         0: Attenuate
                         1: Amplify
              Bit 2-0 - Number of envelope sweep (n: 0-7)
                        (If zero, stop envelope operation.)

              Initial volume of envelope is from 0 to $F.
              Zero being no sound.

              Length of 1 step = n*(1/64) seconds
 
FF18
   Name     - NR 23
   Contents - Sound Mode 2 register, frequency lo data (W)

              Frequency's lower 8 bits of 11 bit data (x).
              Next 3 bits are in NR 14 ($FF19).

FF19
   Name     - NR 24
   Contents - Sound Mode 2 register, frequency hi data (R/W)

              Only bit 6 can be read.

              Bit 7 - Initial
              Bit 6 - Counter/consecutive selection
              Bit 2-0 - Frequency's higher 3 bits (x)

              Frequency = 4194304/(32*(2048-x)) Hz
                        = 131072/(2048-x) Hz

FF1A
   Name     - NR 30
   Contents - Sound Mode 3 register, Sound on/off (R/W)
          
              Only bit 7 can be read

              Bit 7 - Sound OFF
                      0: Sound 3 output stop
                      1: Sound 3 output OK

FF1B
   Name     - NR 31
   Contents - Sound Mode 3 register, sound length (R/W)

              Bit 7-0 - Sound length (t1: 0 - 255)

              Sound Length = (256-t1)*(1/2) seconds

FF1C
   Name     - NR 32
   Contents - Sound Mode 3 register, Select output level
          
              Only bits 6-5 can be read
 
              Bit 6-5 - Select output level
                        00: Mute
                        01: Produce Wave Pattern RAM Data as it is 
                            (4 bit length)
                        10: Produce Wave Pattern RAM data shifted once
                            to the RIGHT (1/2)  (4 bit length)
                        11: Produce Wave Pattern RAM data shifted twice
                            to the RIGHT (1/4)  (4 bit length)

       * - Wave Pattern RAM is located from $FF30-$FF3f.

FF1D
   Name     - NR 33
   Contents - Sound Mode 3 register, frequency's lower data (W)

              Lower 8 bits of an 11 bit frequency (x).

FF1E
   Name     - NR 34
   Contents - Sound Mode 3 register, frequency's higher data (R/W)
 
              Only bit 6 can be read.

              Bit 7 - Initial flag
              Bit 6 - Counter/consecutive flag
              Bit 2-0 - Frequency's higher 3 bits (x).

              Frequency = 4194304/(64*(2048-x)) Hz
                        = 65536/(2048-x) Hz

FF20
   Name     - NR 41
   Contents - Sound Mode 4 register, sound length (R/W)

              Bit 5-0 - Sound length data (t1: 0-63)

              Sound Length = (64-t1)*(1/256) seconds
  
FF21
   Name     - NR 42
   Contents - Sound Mode 4 register, envelope (R/W)

              Bit 7-4 - Initial volume of envelope
              Bit 3 -   Envelope UP/DOWN
                         0: Attenuate
                         1: Amplify
              Bit 2-0 - Number of envelope sweep (n: 0-7)
                        (If zero, stop envelope operation.)

              Initial volume of envelope is from 0 to $F.
              Zero being no sound.

              Length of 1 step = n*(1/64) seconds

FF22
   Name     - NR 43
   Contents - Sound Mode 4 register, polynomial counter (R/W)

              Bit 7-4 - Selection of the shift clock frequency of the
                        polynomial counter
              Bit 3   - Selection of the polynomial counter's step
              Bit 2-0 - Selection of the dividing ratio of frequencies

              Selection of the dividing ratio of frequencies:
              000: f * 1/2^3 * 2
              001: f * 1/2^3 * 1
              010: f * 1/2^3 * 1/2
              011: f * 1/2^3 * 1/3
              100: f * 1/2^3 * 1/4
              101: f * 1/2^3 * 1/5
              110: f * 1/2^3 * 1/6
              111: f * 1/2^3 * 1/7           f = 4.194304 Mhz

              Selection of the polynomial counter step:
              0: 15 steps
              1: 7 steps
  
              Selection of the shift clock frequency of the polynomial
              counter:

              0000: dividing ratio of frequencies * 1/2
              0001: dividing ratio of frequencies * 1/2^2
              0010: dividing ratio of frequencies * 1/2^3
              0011: dividing ratio of frequencies * 1/2^4
                    :                          :
                    :                          : 
                    :                          :
              0101: dividing ratio of frequencies * 1/2^14
              1110: prohibited code
              1111: prohibited code

FF23
   Name     - NR 30
   Contents - Sound Mode 4 register, counter/consecutive; inital (R/W)

              Only bit 6 can be read.
  
              Bit 7 - Inital
              Bit 6 - Counter/consecutive selection                    

FF24
   Name     - NR 50
   Contents - Channel control / ON-OFF / Volume (R/W)

              Bit 7 - Vin->SO2 ON/OFF
              Bit 6-4 - SO2 output level (volume) (# 0-7)
              Bit 3 - Vin->SO1 ON/OFF
              Bit 2-0 - SO1 output level (volume) (# 0-7)

              Vin->SO1 (Vin->SO2)
              
              By synthesizing the sound from sound 1
              through 4, the voice input from Vin
              terminal is put out.
              0: no output
              1: output OK

FF25
    Name     - NR 51
    Contents - Selection of Sound output terminal (R/W)

               Bit 7 - Output sound 4 to SO2 terminal
               Bit 6 - Output sound 3 to SO2 terminal
               Bit 5 - Output sound 2 to SO2 terminal
               Bit 4 - Output sound 1 to SO2 terminal
               Bit 3 - Output sound 4 to SO1 terminal
               Bit 2 - Output sound 3 to SO1 terminal
               Bit 1 - Output sound 2 to SO1 terminal
               Bit 0 - Output sound 0 to SO1 terminal

FF26
    Name     - NR 52
    Contents - Sound on/off (R/W)

               Only Bit 7, 3-0 can be read.

               Bit 7 - All sound on/off
                       0: stop all sound circuits
                       1: operate all sound circuits
               Bit 3 - Sound 4 ON flag
               Bit 2 - Sound 3 ON flag
               Bit 1 - Sound 2 ON flag
               Bit 0 - Sound 1 ON flag

FF30 - FF3F
   Name     - Wave Pattern RAM
   Contents - Waveform storage for arbitrary sound data

              This storage area holds 32 4-bit samples
              that are played back upper 4 bits first.
              
FF40
   Name     - LCDC               (value $91 at reset)
   Contents - LCD Control (R/W)

              Bit 7 - LCD Control Operation *
                      0: Stop completely (no picture on screen)
                      1: operation

              Bit 6 - Window Tile Map Display Select
                      0: $9800-$9BFF
                      1: $9C00-$9FFF

              Bit 5 - Window Display
                      0: off
                      1: on
         
              Bit 4 - BG & Window Tile Data Select
                      0: $8800-$97FF
                      1: $8000-$8FFF <- Same area as OBJ

              Bit 3 - BG Tile Map Display Select
                      0: $9800-$9BFF
                      1: $9C00-$9FFF
           
              Bit 2 - OBJ (Sprite) Size
                      0: 8*8
                      1: 8*16 (height*width)

              Bit 1 - OBJ (Sprite) Display
                      0: off
                      1: on

              Bit 0 - BG Display
                      0: off
                      1: on

       * - Stopping LCD operation (bit 7 from 1 to 0)
           must be performed during V-blank to work
           properly. V-blank can be confirmed when the
           value of LY is greater than or equal to 144.

FF41
   Name     - STAT
   Contents - LCDC Status   (R/W)

              Bits 6-3 - Interrupt Selection By LCDC Status

              Bit 6 - LYC=LY Coincidence (Selectable)
              Bit 5 - Mode 10
              Bit 4 - Mode 01
              Bit 3 - Mode 00
                      0: Non Selection
                      1: Selection

              Bit 2 - Coincidence Flag
                      0: LYC not equal to LCDC LY
                      1: LYC = LCDC LY

              Bit 1-0 - Mode Flag
                        00: Entire Display Ram can be accessed
                        01: During V-Blank
                        10: During Searching OAM-RAM
                        11: During Transfering Data to LCD Driver

     STAT shows the current status of the LCD controller.
     Mode 00: When the flag is 00 it is the H-Blank period
              and the CPU can access the display RAM
              ($8000-$9FFF).

     Mode 01: When the flag is 01 it is the V-Blank period
              and the CPU can access the display RAM
              ($8000-$9FFF).

     Mode 10: When the flag is 10 then the OAM is being
              used ($FE00-$FE9F). The CPU cannot access
              the OAM during this period
     
     Mode 11: When the flag is 11 both the OAM and display
              RAM are being used. The CPU cannot access
              either during this period.


     The following are typical when the display is enabled:

Mode 00  ---___---___---___---___---___---___---________________

Mode 01  _______________________________________--------------__

Mode 02  ___-_____-_____-_____-_____-_____-___________________-_

Mode 03  ____--____--____--____--____--____--__________________-


       The Mode Flag goes through the values 00, 02,
      and 03 at a cycle of about 109uS. 00 is present
      about 49uS, 02 about 20uS, and 03 about 40uS. This
      is interrupted every 16.6ms by the VBlank (01).
      The mode flag stays set at 01 for 1.1 ms.

FF42
   Name     - SCY
   Contents - Scroll Y   (R/W)

              8 Bit value $00-$FF to scroll BG Y screen
              position.

FF43
   Name     - SCX
   Contents - Scroll X   (R/W)
 
              8 Bit value $00-$FF to scroll BG X screen
              position.

FF44
   Name     - LY
   Contents - LCDC Y-Coordinate (R)

            The LY indicates the vertical line to which
            the present data is transferred to the LCD
            Driver. The LY can take on any value between
            0 through 153. The values between 144 and 153
            indicate the V-Blank period. Writing will
            reset the counter.

FF45
   Name     - LYC
   Contents - LY Compare  (R/W)

            The LYC compares itself with the LY. If the
            values are the same it causes the STAT to set
            the coincident flag.

FF46
   Name     - DMA
   Contents - DMA Transfer and Start Address (W)

   The DMA Transfer (40*28 bit) from internal ROM or RAM
   ($0000-$F19F) to the OAM (address $FE00-$FE9F) can be
   performed. It takes 160 microseconds for the transfer.

   40*28 bit = #140  or #$8C.  As you can see, it only
   transfers $8C bytes of data. OAM data is $A0 bytes
   long, from $0-$9F.

   But if you examine the OAM data you see that 4 bits are
   not in use.
   
   40*32 bit = #$A0, but since 4 bits for each OAM is not
   used it's 40*28 bit.

   It transfers all the OAM data to OAM RAM.

   The DMA transfer start address can be designated every
   $100 from address $0000-$F100. That means $0000, $0100,
   $0200, $0300....

    As can be seen by looking at register $FF41 Sprite RAM
   ($FE00 - $FE9F) is not always available. A simple routine
   that many games use to write data to Sprite memory is shown
   below. Since it copies data to the sprite RAM at the appro-
   priate times it removes that responsibility from the main
   program.
    All of the memory space, except high ram ($FF80-$FFFE),
   is not accessible during DMA. Because of this, the routine
   below must be copied & executed in high ram. It is usually
   called from a V-blank Interrupt.

   Example program:

      org $40
      jp VBlank

      org $ff80
VBlank:
      push af        <- Save A reg & flags
      ld a,BASE_ADRS <- transfer data from BASE_ADRS
      ld ($ff46),a   <- put A into DMA registers
      ld a,28h       <- loop length
Wait:                <- We need to wait 160 microseconds.
      dec a          <-  4 cycles - decrease A by 1
      jr nz,Wait     <- 12 cycles - branch if Not Zero to Wait
      pop af         <- Restore A reg & flags
      reti           <- Return from interrupt


FF47
   Name     - BGP
   Contents - BG Palette Data  (W)

              Bit 7-6 - Data for Dot Data 11
              Bit 5-4 - Data for Dot Data 10
              Bit 3-2 - Data for Dot Data 01
              Bit 1-0 - Data for Dot Data 00

              This selects the shade of gray you what for
              your BG pixel. Since each pixel uses 2 bits,
              the corresponding shade will be selected
              from here. The Background Color (00) lies at
              Bits 1-0, just put a value from 0-3 to
              change the color.

FF48
   Name     - OBP0
   Contents - Object Palette 0 Data (W)

              This selects the colors for sprite palette 0.
              It works exactly as BGP ($FF47).
              See BGP for details.

FF49
   Name     - OBP1
   Contents - Object Palette 1 Data (W)

              This Selects the colors for sprite palette 1.
              It works exactly as BGP ($FF47).
              See BGP for details.

FF4A
   Name     - WY
   Contents - Window Y Position  (R/W)

              0 <= WY <= 143

              WY must be greater than or equal to 0 and
              must be less than or equal to 143.

FF4B
   Name     - WX
   Contents - Window X Position  (R/W)

              7 <= WX <= 166

              WX must be greater than or equal to 7 and
              must be less than or equal to 166.


              Lets say WY = 80 and WX = 80.
              The window would be positioned as so:

               0                  80                   159
               __________________________________________
            0 |                   |                      |
              |                   |                      |
              |                   |                      |
              |                   |                      |
              |                   |                      |
              |                   |                      |
              |                   |80                    |
           80 |-------------------+----------------------|
              |                80 |                      |
              |                   |                      |
              |                   |      Window Display  |
              |                   |           Here       |
              |                   |                      |
              |                   |                      |
              |                   |                      |
          143 |___________________|______________________|


          OBJ Characters (Sprites) can still enter the
          window. So can BG characters.

FFFF
   Name     - IE
   Contents - Interrupt Enable (R/W)

              Bit 4: Transition from High to Low of Pin
                     number P10-P13.
              Bit 3: Serial I/O transfer end
              Bit 2: Timer Overflow
              Bit 1: LCDC (see STAT)
              Bit 0: V-Blank

              0: disable
              1: enable
